"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _UnidirectionalIntegration_instances, _UnidirectionalIntegration_onHaIntegration, _UnidirectionalIntegration_isValidVersionforDevices, _UnidirectionalIntegration_removeDevice;
Object.defineProperty(exports, "__esModule", { value: true });
const compare_versions_1 = require("compare-versions");
const const_1 = require("../../const");
const node_1 = require("../../helpers/node");
const Websocket_1 = require("../../homeAssistant/Websocket");
const Events_1 = require("../events/Events");
const helpers_1 = require("./helpers");
const Integration_1 = __importStar(require("./Integration"));
class UnidirectionalIntegration extends Integration_1.default {
    constructor(props) {
        super(props);
        _UnidirectionalIntegration_instances.add(this);
        this.registered = false;
        this.notInstallMessage = 'Node-RED custom integration needs to be installed in Home Assistant for this node to function correctly.';
        this.clientEvents = props.clientEvents;
        this.deviceConfigNode = props.deviceConfigNode;
        this.entityConfigNode = props.entityConfigNode;
    }
    async init() {
        var _a;
        this.entityConfigNode.on(Events_1.NodeEvent.Close, this.onEntityConfigNodeClose.bind(this));
        (_a = this.deviceConfigNode) === null || _a === void 0 ? void 0 : _a.on(Events_1.NodeEvent.Close, this.onDeviceConfigNodeClose.bind(this));
        this.clientEvents.addListeners(this, [
            [Websocket_1.ClientEvent.Close, this.onHaEventsClose],
            [Websocket_1.ClientEvent.Integration, __classPrivateFieldGet(this, _UnidirectionalIntegration_instances, "m", _UnidirectionalIntegration_onHaIntegration)],
        ]);
        if (this.isIntegrationLoaded) {
            await this.registerEntity();
        }
    }
    get isIntegrationLoaded() {
        return this.homeAssistant.isIntegrationLoaded;
    }
    get isRegistered() {
        return this.registered;
    }
    async onEntityConfigNodeClose(removed, done) {
        if (this.registered && this.isIntegrationLoaded && removed) {
            try {
                await this.unregisterEntity();
            }
            catch (err) {
                done(err);
            }
        }
        done();
    }
    async onDeviceConfigNodeClose(removed, done) {
        if (this.registered && this.isIntegrationLoaded && removed) {
            try {
                await __classPrivateFieldGet(this, _UnidirectionalIntegration_instances, "m", _UnidirectionalIntegration_removeDevice).call(this);
            }
            catch (err) {
                done(err);
            }
        }
        done();
    }
    onHaEventsClose() {
        this.registered = false;
    }
    getDeviceInfo() {
        if (!this.deviceConfigNode) {
            return undefined;
        }
        const config = this.deviceConfigNode.config;
        return {
            id: config.id,
            hw_version: config.hwVersion,
            name: config.name,
            manufacturer: config.manufacturer,
            model: config.model,
            sw_version: config.swVersion,
        };
    }
    getStateData(state) {
        if (!state) {
            return {};
        }
        let data = {};
        switch (this.entityConfigNode.config.entityType) {
            case const_1.EntityType.BinarySensor:
            case const_1.EntityType.Sensor: {
                if (this.entityConfigNode.config.resend && state) {
                    const lastPayload = state.getLastPayload();
                    if (lastPayload) {
                        data = { ...lastPayload };
                    }
                }
                break;
            }
        }
        return data;
    }
    getDiscoveryPayload({ config, remove, state, }) {
        const deviceInfo = this.getDeviceInfo();
        const message = {
            ...this.getStateData(state),
            type: Integration_1.MessageType.Discovery,
            server_id: this.entityConfigNode.config.server,
            node_id: this.entityConfigNode.id,
            config,
            component: this.entityConfigNode.config.entityType,
            remove,
            device_info: deviceInfo,
        };
        return message;
    }
    getEntityPayload(state, attributes) {
        return {
            type: Integration_1.MessageType.Entity,
            server_id: this.entityConfigNode.config.server,
            node_id: this.entityConfigNode.id,
            state,
            attributes,
        };
    }
    async registerEntity() {
        if (!this.isIntegrationLoaded) {
            this.entityConfigNode.error(this.notInstallMessage);
            this.status.forEach((status) => status.setFailed('home-assistant.status.error'));
            return;
        }
        if (this.isRegistered)
            return;
        const config = (0, helpers_1.createHaConfig)(this.entityConfigNode.config.haConfig);
        const payload = this.getDiscoveryPayload({
            config,
            state: this.state,
        });
        this.debugToClient('register', payload);
        this.entityConfigNode.debug(`Registering ${this.entityConfigNode.config.entityType} with HA`);
        try {
            await this.homeAssistant.websocket.send(payload);
        }
        catch (err) {
            this.status.forEach((status) => status.setFailed('Error registering'));
            const message = err instanceof Error ? err.message : err;
            this.entityConfigNode.error(`Error registering entity. Error Message: ${message}`);
            return;
        }
        this.status.forEach((status) => status === null || status === void 0 ? void 0 : status.setSuccess('Registered'));
        this.registered = true;
    }
    setStatus(status) {
        this.status.push(status);
    }
    async updateStateAndAttributes(state, attributes) {
        const payload = this.getEntityPayload(state, attributes);
        await this.homeAssistant.websocket.send(payload);
        if (this.entityConfigNode.config.resend) {
            const lastPayload = {
                state,
                attributes,
            };
            this.state.setLastPayload(lastPayload);
        }
        this.debugToClient('update state', payload);
        return payload;
    }
    async unregisterEntity() {
        var _a;
        this.entityConfigNode.debug(`Unregistering ${this.entityConfigNode.config.entityType} node from HA`);
        const payload = this.entityConfigNode.integration.getDiscoveryPayload({
            remove: true,
        });
        this.debugToClient('unregister', payload);
        await ((_a = this.homeAssistant) === null || _a === void 0 ? void 0 : _a.websocket.send(payload));
    }
    debugToClient(topic, message) {
        (0, node_1.debugToClient)(this.entityConfigNode, message, topic);
    }
}
exports.default = UnidirectionalIntegration;
_UnidirectionalIntegration_instances = new WeakSet(), _UnidirectionalIntegration_onHaIntegration = async function _UnidirectionalIntegration_onHaIntegration(type) {
    switch (type) {
        case Integration_1.IntegrationState.Loaded:
            await this.registerEntity();
            break;
        case Integration_1.IntegrationState.Unloaded:
        case Integration_1.IntegrationState.NotLoaded:
            this.registered = false;
            break;
    }
}, _UnidirectionalIntegration_isValidVersionforDevices = function _UnidirectionalIntegration_isValidVersionforDevices() {
    return ((0, compare_versions_1.compareVersions)(`${this.homeAssistant.websocket.integrationVersion}`, '1.1') >= 0);
}, _UnidirectionalIntegration_removeDevice = async function _UnidirectionalIntegration_removeDevice() {
    var _a;
    if (!this.deviceConfigNode || !__classPrivateFieldGet(this, _UnidirectionalIntegration_instances, "m", _UnidirectionalIntegration_isValidVersionforDevices).call(this))
        return;
    this.deviceConfigNode.debug(`Removing device from Home Assistant: ${this.deviceConfigNode.config.name}`);
    await ((_a = this.homeAssistant) === null || _a === void 0 ? void 0 : _a.websocket.send({
        type: Integration_1.MessageType.RemoveDevice,
        node_id: this.deviceConfigNode.id,
    }));
};
